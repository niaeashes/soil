#!/usr/bin/env node

import { promises as fs } from 'fs'
import path from 'path'
import util from 'util'
import YAML from 'yaml'

const loadConfig = async function () {
  const DEFAULT_CONFIG = {
    workingDir: '.',
    exportDir: 'dist',
    encoding: 'utf-8',
  }
  try {
    return Object.assign({}, DEFAULT_CONFIG, (await import(path.join(process.cwd(), './soil.config.js'))).default)
  } catch (error) {
    return Object.assign({}, DEFAULT_CONFIG)
  }
}

const main = async function() {
  const config = await loadConfig()
  const soil = new Soil(config)
  await soil.loadEntity()
  await soil.exportSwiftCode()
  soil.debug()
}

class Soil {
  constructor(config) {
    Object.defineProperty(this, 'config', { value: config, enumerable: true })
  }

  async loadEntity () {
    const workingDirPath = path.join(process.cwd(), this.config.workingDir)

    const entityFiles = await fs.readdir(path.join(workingDirPath, 'entity'))
    this.entities = []
    for (const file of entityFiles) {
      const fullpath = path.join(workingDirPath, 'entity', file)
      const entity = YAML.parse(await fs.readFile(fullpath, this.config.encoding))
      this.entities.push(new Entity(entity))
    }
  }

  async exportOpenApiSchema() {
  }

  async exportSwiftCode() {
    this.entities.forEach(entity => {
      console.log(entity.convertSwiftFragment().render(0))
    })
  }

  async exportKotlinCode() {
  }

  debug () {
    console.log(util.inspect(this, { depth: null, colors: true }))
  }
}

class Entity {
  constructor (schema) {
    this.name = schema.name
    const fields = Object.keys(schema.fields).map(name => new Field(name, schema.fields[name]))
    const endpoints = Object.keys(schema.endpoints).map(path => new Endpoint(path, schema.endpoints[path]))
    Object.defineProperty(this, 'schema', { value: schema })
    Object.defineProperty(this, 'fields', { value: fields, enumerable: true })
    Object.defineProperty(this, 'endpoints', { value: endpoints, enumerable: true })
  }

  fieldSchema (name) {
    const field = this.fields.find(field => field.name == name)
    if (field) {
      return field.schema
    } else {
      return {}
    }
  }

  convertSwiftFragment () {
    const fragment = new CodeFragment()
    fragment.docComment = swift.docComment(
      '',
      `${this.name}.swift`,
      'Generated by soil',
      '',
    )
    fragment.header = `public class ${this.name}: Decodable {`
    fragment.fragments = [
      ...this.fields.map(field => field.convertSwiftFragment()),
      ...this.endpoints.map(field => field.convertSwiftFragment(this)),
    ]
    fragment.footer = '}'
    return fragment
  }
}

class Field {

  constructor (name, schema) {
    this.name = name
    Object.defineProperty(this, 'schema', { value: schema })
  }

  get summary () { return this.schema.summary }
  get description () { return this.schema.description }

  convertSwiftFragment () {
    const fragment = new CodeFragment()
    const type = swift.convertType(this.schema.type)
    fragment.docComment = swift.docComment(
      this.summary,
      this.description ? '' : null,
      this.description,
    )
    fragment.header = `var ${this.name}: ${type}`
    return fragment
  }
}

class Endpoint {
  constructor (path, schema) {
    this.path = path
    Object.defineProperty(this, 'schema', { value: schema })
  }
  convertSwiftFragment (entity) {
    var collection = []
    console.log(this.schema)
    if (this.schema.get) {
      collection.push((new EndpointMethod(this, this.schema.get, 'GET')).convertSwiftFragment(entity))
    }
    return new FragmentCollection(collection)
  }
}

class EndpointMethod {
  constructor (endpoint, schema, method) {
    this.endpoint = endpoint
    this.method = method
    Object.defineProperty(this, 'schema', { value: schema })
  }

  get path () {
    return this.endpoint.path
  }

  get name () {
    return this.schema.summary
      .replace(/\s/, '')
  }

  convertSwiftFragment (entity) {
    const fragment = new CodeFragment()
    fragment.header = `struct ${this.name}Endpoint: ApiEndpoint {`
    fragment.fragments.push(`var path = "${this.path}"`)
    fragment.fragments.push(`let method: HTTPMethod = .${this.method}`)
    fragment.fragments.push(new EndpointInitializer(this.endpoint, this).convertSwiftFragment(entity))
    fragment.fragments.push(new EndpointResponse(this.endpoint, this).convertSwiftFragment(entity))
    fragment.footer = '}'
    return fragment
  }
}

class EndpointPath {
  constructor (path) {
    this.path = path
  }

  get pathParameters () {
    return this.path.split('/')
      .filter(part => part[0] == '{' && part[part.length - 1] == '}')
      .map(part => part.substring(1, part.length - 1))
  }
}

class EndpointInitializer {
  constructor (endpoint, method) {
    this.endpoint = endpoint
    this.method = method
  }

  get path () {
    return this.endpoint.path
  }

  convertSwiftFragment (entity) {
    const pathParameters = new EndpointPath(this.path)
      .pathParameters
      .map(param => { return { name: param, ...entity.fieldSchema(param) } })

    const fragment = new CodeFragment()
    fragment.header = `init(${swift.funcArgs(...pathParameters)}) {`
    if (pathParameters.length > 0) {
      fragment.fragments.push('self.path = path')
      pathParameters
        .forEach(param => fragment.fragments.push(`  .replacingOccurrences(of: "{${param.name}}", with: ${param.name})`))
    }
    fragment.footer = '}'
    return fragment
  }
}

class EndpointResponse {
  constructor (endpoint, method) {
    this.endpoint = endpoint
    this.method = method
  }

  convertSwiftFragment (entity) {
    const fragment = new CodeFragment()
    const successSchema = this.method.schema.success.schema
    fragment.header = 'struct Response: Decodable {'
    Object.keys(successSchema).forEach(name => {
      fragment.fragments.push(`let ${name}: ${swift.convertType(successSchema[name])}`)
    })
    fragment.footer = '}'
    return fragment
  }
}

class FragmentCollection {
  constructor(fragments) {
    this.fragments = fragments
  }
  render (indent) {
    return this.fragments.map(fragment => fragment.render(indent)).join("\n")
  }
}

class CodeFragment {
  constructor() {
    this.fragments = []
    this.docComment = ''
    this.header = ''
    this.footer = ''
  }
  render (indent) {
    var result = []
    if (this.docComment != '') {
      result.push(this.docComment.split("\n").map(line => `${'  '.repeat(indent)}${line}`).join("\n"))
    }
    result.push(this.header.split("\n").map(line => `${'  '.repeat(indent)}${line}`).join("\n"))
    this.fragments.forEach(fragment => {
      if (typeof fragment == 'string') {
        result.push(fragment.split("\n").map(line => `${'  '.repeat(indent + 1)}${line}`).join("\n"))
      } else {
        result.push(fragment.render(indent + 1))
      }
    })
    result.push(this.footer.split("\n").map(line => `${'  '.repeat(indent)}${line}`).join("\n"))
    return result.join("\n")
  }
}

const SWIFT_TYPE_TABLE = {
  'string': 'String',
  'integer': 'Int',
}

const swift = {
  docComment (...lines) {
    return lines.flat().filter(line => typeof line == 'string').map(line => `/// ${line}`).join("\n")
  },
  funcArgs (...vars) {
    return vars.map(item => [item.label, `${item.name}:`, swift.convertType(item.type)].filter(line => typeof line == 'string').join(" ")).join(', ')
  },
  convertType (type) {
    if (SWIFT_TYPE_TABLE[type]) {
      return SWIFT_TYPE_TABLE[type]
    }
    return type
  }
}

main()
