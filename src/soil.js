#!/usr/bin/env node

import { promises as fs } from 'fs'
import path from 'path'
import util from 'util'
import YAML from 'yaml'

const loadConfig = async function () {
  const DEFAULT_CONFIG = {
    workingDir: '.',
    exportDir: 'dist',
    encoding: 'utf-8',
    swift: {
      indent: '    ',
      imports: ['Foundation'],
      protocols: {
        entity: 'Decodable',
        writableEntity: 'Encodable',
        endpoint: null,
      },
    },
  }
  try {
    return Object.assign({}, DEFAULT_CONFIG, (await import(path.join(process.cwd(), './soil.config.js'))).default)
  } catch (error) {
    return Object.assign({}, DEFAULT_CONFIG)
  }
}

const main = async function() {
  const config = await loadConfig()
  const soil = new Soil(config)
  await soil.prepare()
  await soil.exportSwiftCode()
  soil.debug()
}

class CodeElement {

  constructor(name, context) {
    Object.defineProperty(this, 'name', { value: name, enumerable: true })
    Object.defineProperty(this, 'context', { value: context })
  }
}

class Soil extends CodeElement {
  constructor(config) {
    super('Soil', { config })
    Object.defineProperty(this, 'config', { value: config })
  }

  async prepare() {
    const workingDirPath = path.join(process.cwd(), this.config.workingDir)

    const entities = (await fs.readdir(path.join(workingDirPath, 'entity')))
      .map(async (file) => {
        const fullpath = path.join(workingDirPath, 'entity', file)
        return YAML.parse(await fs.readFile(fullpath, this.config.encoding))
      })

    Object.defineProperty(this, 'entities', { value: await Promise.all(entities), enumerable: true })
  }

  async exportOpenApiSchema() {
  }

  async exportSwiftCode() {
    this.entities.forEach(async (schema) => {
      const entity = new Entity(schema.name, schema, { entities: this.entities, ...this.context })
      const body = await entity.renderSwiftFile()
      fs.writeFile(path.join(process.cwd(), this.config.exportDir, `${entity.name}.swift`), body, this.config.encode)
      console.log(body)
    })
  }

  async exportKotlinCode() {
  }

  debug () {
    console.log(util.inspect(this, { depth: null, colors: true }))
  }
}

class Entity extends CodeElement {
  constructor (name, schema, context) {
    super(name, { entity: schema, ...context })
    Object.defineProperty(this, 'schema', { value: schema })
  }

  get summary () {
    return this.schema.summary
  }

  get description () {
    return this.schema.description
  }

  get fields () {
    return Object.keys(this.schema.fields)
      .map(name => new Field(name, this.schema.fields[name], this.context))
  }

  get readerFields () {
    return this.fields.filter(field => field.annotations.indexOf('WriteOnly') == -1)
  }

  get writerFields () {
    return this.fields
      .filter(field => field.annotations.indexOf('ReadOnly') == -1)
      .filter(field => field.annotations.indexOf('AutoGenerated') == -1)
  }

  get endpoints () {
    return Object.keys(this.schema.endpoints)
      .map(path => {
        const endpoint = this.schema.endpoints[path]
        return ['get', 'post', 'put', 'patch', 'delete']
          .filter(method => endpoint[method])
          .map(method => new Endpoint(path, method, { parameters: endpoint.parameters, ...endpoint[method] }, this.context))
      })
      .flat()
  }

  renderSwiftFile () {
    const { imports } = this.context.config.swift
    const protocol = this.context.config.swift.protocols.entity
    var result = [`struct ${this.name}: ${protocol}`]
    var hasDescription = false
    if (typeof this.description == 'string') {
      result.unshift(...this.description.trim().split('\n').map(line => `/// ${line}`))
      var hasDescription = true
    }
    if (typeof this.summary == 'string') {
      if (hasDescription) {
        result.unshift('///')
      }
      result.unshift(...this.summary.split('\n').map(line => `/// ${line}`))
    }
    return imports.map(name => `import ${name}`).join('\n') + swift.pretty(result.join('\n').block(
      ...this.readerFields.map(field => field.renderSwiftMember()),
      new WritableEntity(this).renderSwift(),
      ...this.endpoints.map(endpoint => endpoint.renderSwift()),
    ).render(this.context), this.context.config)
  }
}

class Field extends CodeElement {
  constructor (name, schema, context) {
    super(name, { field: schema, ...context })
  }

  get type () {
    const { define } = this.context.field
    const tokens = define.split(/\s/)
    return tokens[tokens.length - 1]
  }

  get annotations () {
    const { define } = this.context.field
    return define.split(/\s/)
      .filter(token => token[0] == '+')
      .map(token => token.replace(/^\+/, ''))
  }

  get summary () {
    return this.context.field.summary
  }

  get description () {
    return this.context.field.description
  }

  renderSwiftMember () {
    var signature = 'public var'
    if (this.annotations.indexOf('ReadOnly') != -1) {
      signature = 'public private(set) var'
    }
    if (this.annotations.indexOf('AutoGenerated') != -1) {
      signature = 'public let'
    }
    var result = [`${signature} ${this.name}: ${swift.convertType(this.type)}`]
    var hasDescription = false
    if (typeof this.description == 'string') {
      result.unshift(...this.description.trim().split('\n').map(line => `/// ${line}`))
      var hasDescription = true
    }
    if (typeof this.summary == 'string') {
      if (hasDescription) {
        result.unshift('///')
      }
      result.unshift(...this.summary.split('\n').map(line => `/// ${line}`))
    }
    return result.join("\n")
  }

  renderSwiftParam () {
    return `${this.name}: ${swift.convertType(this.type)}`
  }

  swiftStringify () {
    switch (this.type) {
      case 'Integer':
        return `"\(${this.name})"`
    }
    return this.name
  }
}

class WritableEntity extends CodeElement {
  constructor (entity) {
    super(entity.name, entity.context)
    Object.defineProperty(this, 'entity', { value: entity })
  }

  get fields () {
    return this.entity.fields
  }

  get readerFields () {
    return this.entity.readerFields
  }

  get writerFields () {
    return this.entity.writerFields
  }

  renderSwift () {
    const protocol = this.context.config.swift.protocols.writableEntity
    return `public struct Writable${this.name}: ${protocol}`.block(
      `public init(${this.writerFields.map(field => field.renderSwiftParam()).join(', ')})`.block(
        ...this.writerFields.map(field => `this.${field.name} = ${field.name}`),
      ),
      ...this.writerFields.map(field => field.renderSwiftMember()),
    ).render(this.context)
  }
}

class Endpoint extends CodeElement {
  constructor (path, method, schema, context) {
    super(path, { endpoint: { path, method, ...schema }, ...context })
    Object.defineProperty(this, 'schema', { value: { path, method, ...schema } })
    Object.defineProperty(this, 'method', { value: method, enumerable: true })
    Object.defineProperty(this, 'path', { value: path, enumerable: true })
  }

  get summary () {
    return this.schema.summary
  }

  get description () {
    return this.schema.description
  }

  get signature () {
    return `${this.summary.replace(/\s/g, '')}Endpoint`
  }

  get pathParameters () {
    return this.path
      .split('/')
      .filter(token => /^\{[a-zA-Z_\-]+\}$/.test(token))
      .map(token => {
        const name = token.substring(1, token.length - 1)
        const field = this.context.entity.fields[name]
        if (field) {
          return new Field(name, field)
        }
        const parameter = this.schema.parameters[name]
        if (parameter) {
          const reference = parameter.ref.split('.')
          var targetEntity = null
          if (reference.length > 1) {
            for (var token of reference) {
              const hitEntity = this.context.entities.find(entity => entity.name == token)
              if (hitEntity) {
                targetEntity = hitEntity
                continue
              }
              const hitField = targetEntity.fields[token]
              if (hitField) {
                return new Field(name, hitField)
              }
            }
          }
        }
        return null
      })
      .filter(param => param != null)
  }

  renderSwift () {
    const protocol = this.context.config.swift.protocols.endpoint
    var result = [`public struct ${this.signature}${protocol == null ? '' : `: ${protocol}`}`]
    var hasDescription = false
    if (typeof this.description == 'string') {
      result.unshift(...this.description.trim().split('\n').map(line => `/// ${line}`))
      var hasDescription = true
    }
    if (typeof this.summary == 'string') {
      if (hasDescription) {
        result.unshift('///')
      }
      result.unshift(...this.summary.split('\n').map(line => `/// ${line}`))
    }
    return result.join('\n').block(
      `public let method: String = "${this.method.toUpperCase()}"`,
      'public let path: String',
      `public init(${this.pathParameters.map(param => typeof param.renderSwiftParam == 'function' ? param.renderSwiftParam() : param).join(', ')})`.block(
        `this.path = "${this.path}"`,
        ...this.pathParameters.map(param => `.replacingOccurrences(of: "{${param.name}}", with: ${param.swiftStringify()})`),
      ),
      new RequestBody((this.schema.request || {}).schema || null, this.context).renderSwift(),
      new Response(this.schema.success.schema, this.context).renderSwift(),
    ).render(this.context)
  }
}

class RequestBody extends CodeElement {

  constructor(schema, context) {
    super('request', { request: schema, ...context })
  }

  renderSwift() {
    if (this.context.request == null) { return 'public typealias RequestBody = Void' }
    return `public struct RequestBody: Encodable`.block(
      ...Object.keys(this.context.request).map(name => `let ${name}: Writable${swift.convertType(this.context.request[name])}`),
    ).render(this.context)
  }
}

class Response extends CodeElement {

  constructor(schema, context) {
    super('response', { response: schema, ...context })
  }

  renderSwift() {
    if (this.context.response == null) { return 'public typealias Response = Void' }
    return `public struct Response: Decodable`.block(
      ...Object.keys(this.context.response).map(name => `let ${name}: ${swift.convertType(this.context.response[name])}`),
    ).render(this.context)
  }
}

String.prototype.block = function (...contents) {
  return (new CodeBlock(this, '{}', ...contents))
}

class CodeBlock {
  constructor (header, wrapper = '{}', ...contents) {
    this.header = header
    this.blockStartToken = wrapper[0]
    this.blockEndToken = wrapper[1]
    this.contents = contents
  }

  render (context) {
    return [
      `${this.header} ${this.blockStartToken}`,
      ...this.contents.map(content => typeof content.render == 'function' ? `${content.render(context)}` : `${content}`),
      this.blockEndToken,
    ].join("\n")
  }
}

const SWIFT_TYPE_TABLE = {
  'String': 'String',
  'Integer': 'Int',
}

const swift = {
  indendSize: 4,
  docComment (...lines) {
    return lines.flat().filter(line => typeof line == 'string').map(line => `/// ${line}`).join("\n")
  },
  funcArgs (...vars) {
    return vars.map(item => [item.label, `${item.name}:`, swift.convertType(item.type)].filter(line => typeof line == 'string').join(" ")).join(', ')
  },
  convertType (type) {
    if (SWIFT_TYPE_TABLE[type]) {
      return SWIFT_TYPE_TABLE[type]
    }
    if (/^List\<.+\>$/.test(type)) {
      const element = type.match(/^List\<(.+)\>$/)[1]
      return `Array<${this.convertType(element)}>`
    }
    return type
  },
  pretty (code, config) {
    const lines = code.split('\n')
    const { indent } = config.swift
    var result = []
    var indentLevel = 0
    var commentBuffer = []
    for (var line of lines) {
      if (line.startsWith('///')) {
          commentBuffer.push(`${indent.repeat(indentLevel)}${line}`)
          continue
      }
      const hasBlockSignature = /^(?:(public|open|private|fileprivate)(?:\(set\))?\s+)*(var|let|struct|class|init|deinit|func|protocol|typealias)/.test(line)
      if (hasBlockSignature) {
          result.push('')
          result.push(...commentBuffer)
      }
      if (line.startsWith('.')) {
        indentLevel += 1
      }
      if (line == '}') {
        indentLevel -= 1
      }
      result.push(`${indent.repeat(indentLevel)}${line}`)
      if (hasBlockSignature && line.endsWith('{')) {
        indentLevel += 1
      }
      if (line.startsWith('.')) {
        indentLevel -= 1
      }
      commentBuffer = []
    }
    return result.join('\n')
  },
}

main()
